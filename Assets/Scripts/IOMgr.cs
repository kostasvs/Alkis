using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using UnityEngine;
using UnityEngine.UI;

public class IOMgr : MonoBehaviour
{

	// reference to this singleton
	public static IOMgr me;

	/// <summary>
	/// Enum for all available controls.
	/// </summary>
	public enum Control
	{
		Roll_Left, Roll_Right, Nose_Up, Nose_Down, Thrust_Set_To, Thrust_Increase, Thrust_Decrease,
		Fire_Guns, Look_Back
	}

	/// <summary>
	/// control names (autogenerated by Control enum)
	/// </summary>
	public static string[] ControlNames { get; protected set; }
	/// <summary>
	/// names for all KeyCodes (autogenerated by KeyCode enum)
	/// </summary>
	public static string[] KeyNames { get; protected set; }
	/// <summary>
	/// values of all KeyCodes (autogenerated by KeyCode enum)
	/// </summary>
	public static int[] KeyValues { get; protected set; }

	/// <summary>
	/// array of type per control. types: -2 = keyboard/gamepad, -1 = mousewheel, 0+ = gamepad axis
	/// </summary>
	public static int[] ctrlType = { -2, -2, -2, -2, -2, -2, -2, -2, -2 };
	
	/// <summary>
	/// array of value per control. KeyCode if button, axis number if gamepad axis, 0(down)/1(up) if mousewheel
	/// </summary>
	public static int[] ctrlVal = { (int)KeyCode.A, (int)KeyCode.D, (int)KeyCode.W, (int)KeyCode.S,
		-1, (int)KeyCode.Mouse0, (int)KeyCode.Mouse1, (int)KeyCode.LeftControl, (int)KeyCode.LeftShift};
	/// <summary>
	/// array of min limit per control (only used for gamepad axis controls)
	/// </summary>
	public static float[] ctrlLimitMin;
	/// <summary>
	/// array of max limit per control (only used for gamepad axis controls)
	/// </summary>
	public static float[] ctrlLimitMax;

	/// <summary>
	/// max gamepads to check for
	/// </summary>
	public const int maxGamepads = 4;
	/// <summary>
	/// max gamepad axes (per gamepad) to check for
	/// </summary>
	public const int maxAxes = 28;

	/// <summary>
	/// filepath of config file to use (optional)
	/// </summary>
	public static string configFile = "";

	public static bool initialized { get; protected set; }

	public GameObject assignerPrefab;
	public Transform backButton;
	private Button[] assignButtons;
	public string assignText = "Hold button / stick";
	//public Color assignColorHighlight;
	//private Color assignColorDefault;
	private int assignWaiting = -1;
	private float[][] watchAxes;
	private float watchTimer;
	private int watchFocusType = -3;
	private int watchFocusValue = -1;
	//private float watchFocusPrev = 0;
	private string tempAxis;
	public float assignNeededDuration = .6f;

	private int gettingStickLimits = 0;
	public GameObject stickLimitsDialog;
	private CanvasGroup stickLimitsDialogCG;
	private Text stickLimitsDialogText;
	public string stickLimitsDialogPromptMin = "Leave \"%1\" to <b>MIN</b> (zero) position\nand click or press Enter\n(Esc = cancel)";
	public string stickLimitsDialogPromptMax = "Hold \"%1\" to <b>MAX</b> position\nand click or press Enter\n(Esc = cancel)";
	public string stickLimitsDialogPromptFailed = "Min - Max difference too small,\nplease try again!";
	public const float stickLimitsDialogPromptFadeDur = .25f;
	public const float stickLimitsDialogPromptLingerDur = 1f;
	private float stickLimitsDialogPromptTimer;
	private float stickLimitsTempMin;
	private float stickLimitsTempMax;
	public const float stickLimitsRequiredLimitDiff = .25f;
	private int stickLimitsTempControl;
	private int stickLimitsTempGamepad;
	private int stickLimitsTempAxis;

	public static void Init()
	{

		if (initialized) return;

		// ensure arrays initialized
		if (ctrlLimitMin == null || ctrlLimitMin.Length == 0) ctrlLimitMin = new float[ctrlVal.Length];
		if (ctrlLimitMax == null || ctrlLimitMax.Length == 0) ctrlLimitMax = new float[ctrlVal.Length];

		// default config filepath
		if (configFile.Equals(string.Empty))
			configFile = Application.persistentDataPath + "/InputConfig.xml";

		// generate names of controls
		ControlNames = Enum.GetNames(typeof(Control));
		// generate names/values of KeyCodes
		KeyValues = (int[])Enum.GetValues(typeof(KeyCode));
		KeyNames = Enum.GetNames(typeof(KeyCode));
		// beautify some key names
		for (int i = 0; i < KeyNames.Length; i++)
		{
			// alphanumeric keys
			if (KeyValues[i] >= (int)KeyCode.Alpha0 && KeyValues[i] < (int)KeyCode.Alpha0 + 10)
				KeyNames[i] = (KeyValues[i] - (int)KeyCode.Alpha0).ToString();
			// numpad keys
			if (KeyValues[i] >= (int)KeyCode.Keypad0 && KeyValues[i] < (int)KeyCode.Keypad0 + 10)
				KeyNames[i] = "Num " + (KeyValues[i] - (int)KeyCode.Keypad0).ToString();
		}

		initialized = true;
	}

	private void Awake()
	{

		// check for duplicate singleton
		if (me && me != this)
		{
			Debug.LogWarning("duplicate IOMgr");
			enabled = false;
			return;
		}
		me = this;
		
		Init();
		ReadConfig();

		if (!assignerPrefab) return;

		// build config menu
		assignButtons = new Button[ControlNames.Length];
		for (int i = 0; i < ControlNames.Length; i++)
		{
			// create assigner button for this control
			var go = assignerPrefab;
			if (!go.activeSelf) go.SetActive(true);
			else go = Instantiate(go, go.transform.parent);
			var rtr = go.GetComponent<RectTransform>();
			
			//Debug.Log (ControlNames[i].Replace ('_', ' ') + " = " + GetControlValueName ((Control)i));
			
			// set text to control name
			go.GetComponentInChildren<Text>().text = ControlNames[i].Replace('_', ' ');
			var btn = go.GetComponentInChildren<Button>();
			btn.GetComponentInChildren<Text>().text = GetControlValueName((Control)i);
			//if (i == 0) assignColorDefault = btn.GetComponent<Image> ().color;
			assignButtons[i] = btn;
			int j = i;
			btn.onClick.AddListener(delegate { BeginAssign(j); });
		}
		// ensure back button stays at bottom
		if (backButton) backButton.SetAsLastSibling();

		if (stickLimitsDialog)
		{
			stickLimitsDialogCG = stickLimitsDialog.GetComponent<CanvasGroup>();
			stickLimitsDialogText = stickLimitsDialog.transform.GetChild(0).GetChild(0).GetComponent<Text>();
		}

		watchAxes = new float[maxGamepads][];
		for (int i = 0; i < maxGamepads; i++) watchAxes[i] = new float[maxAxes];
	}
	private void Start()
	{
		// initially hide this object (after Awake done)
		gameObject.SetActive(false);
	}
	private void OnDisable()
	{
		// ensure assign exited on disable
		CancelAssign();
	}
	private void OnDestroy()
	{
		// ensure config save on game/scene exit
		WriteConfig();
	}

	private void Update()
	{

		//if (Input.GetKeyDown (KeyCode.Escape) && HandleEscape ()) return;
		if (assignWaiting != -1) UpdateAssignProcess();
		if (gettingStickLimits != 0) UpdateStickLimitsProcess();
	}

	public bool HandleEscape()
	{

		if (assignWaiting != -1)
		{
			// pending assign, cancel it
			CancelAssign();
			return true;
		}
		if (gettingStickLimits != 0)
		{
			// pending stick adjust, cancel it
			CancelStickLimits();
			return true;
		}
		// nothing to cancel
		return false;
	}

	/// <summary>
	/// show dialog for adjusting limits for given axis control
	/// </summary>
	/// <param name="ControlIndex">control to adjust (see Control enum)</param>
	private void BeginStickLimits(int ControlIndex)
	{
		// prepare to get limits for given control
		gettingStickLimits = 1;
		stickLimitsTempControl = ControlIndex;

		// show & prepare dialog
		stickLimitsDialog.SetActive(true);
		stickLimitsDialogCG.alpha = 1f;
		stickLimitsDialogText.text = stickLimitsDialogPromptMin.Replace("%1",
			ControlNames[stickLimitsTempControl].Replace('_', ' '));
		stickLimitsDialogPromptTimer = 0f;
	}

	/// <summary>
	/// abort stick limits adjust
	/// </summary>
	public void CancelStickLimits()
	{

		if (gettingStickLimits == 0) return;
		stickLimitsDialog.SetActive(false);
		stickLimitsDialogPromptTimer = 0;
		gettingStickLimits = 0;
	}

	private void UpdateStickLimitsProcess()
	{
		// check for confirm
		if (Input.GetKeyDown(KeyCode.Return) || Input.GetKeyDown(KeyCode.KeypadEnter) ||
			Input.GetMouseButtonDown(0))
		{
			if (gettingStickLimits == 1)
			{
				// get min limit
				stickLimitsTempMin = Input.GetAxisRaw(tempAxis);
				gettingStickLimits++;
				stickLimitsDialogText.text = stickLimitsDialogPromptMax.Replace("%1",
					ControlNames[stickLimitsTempControl].Replace('_', ' '));
				if (Globals.me) Globals.me.MenuSound(0);
			}
			else if (gettingStickLimits == 2)
			{
				// get max limit
				stickLimitsTempMax = Input.GetAxisRaw(tempAxis);
				gettingStickLimits++;
				if (Mathf.Abs(stickLimitsTempMax - stickLimitsTempMin) < stickLimitsRequiredLimitDiff)
				{
					// min/max limit too close, show fail message
					stickLimitsDialogText.text = stickLimitsDialogPromptFailed;
					gettingStickLimits++;
				}
				if (Globals.me) Globals.me.MenuSound(0);
			}
		}
		if (gettingStickLimits == 4)
		{
			// linger to show fail message
			stickLimitsDialogPromptTimer += Time.unscaledDeltaTime;
			if (stickLimitsDialogPromptTimer > stickLimitsDialogPromptLingerDur)
			{
				stickLimitsDialogPromptTimer = 0;
				gettingStickLimits++;
				if (Globals.me) Globals.me.MenuSound(0);
			}
		}
		else if (gettingStickLimits == 3 || gettingStickLimits == 5)
		{
			// fade out dialog
			stickLimitsDialogPromptTimer += Time.unscaledDeltaTime;
			stickLimitsDialogCG.alpha = 1f - stickLimitsDialogPromptTimer / stickLimitsDialogPromptFadeDur;
			if (stickLimitsDialogPromptTimer > stickLimitsDialogPromptFadeDur)
			{
				if (gettingStickLimits == 3)
				{
					// this was a successful set, store the given axis and limits
					ctrlType[stickLimitsTempControl] = stickLimitsTempGamepad;
					ctrlVal[stickLimitsTempControl] = stickLimitsTempAxis;
					ctrlLimitMin[stickLimitsTempControl] = stickLimitsTempMin;
					ctrlLimitMax[stickLimitsTempControl] = stickLimitsTempMax;
					assignButtons[stickLimitsTempControl].GetComponentInChildren<Text>().text =
					GetControlValueName((Control)stickLimitsTempControl);
					Debug.Log("Assign " + ControlNames[stickLimitsTempControl] + ": " +
						GetControlValueName((Control)stickLimitsTempControl) + ", " +
						stickLimitsTempMin + " - " + stickLimitsTempMax);
					if (Globals.me) Globals.me.MenuSound(0);
				}
				CancelStickLimits();
			}
		}
	}

	private void UpdateAssignProcess()
	{

		bool focusing = false;
		var filler = assignButtons[assignWaiting].transform.Find("filler");
		if (watchFocusType == -2)
		{
			// fill up while button held down
			if (Input.GetKey((KeyCode)watchFocusValue)) focusing = true;
		}
		else if (watchFocusType >= 0)
		{
			// gamepad axis

			//if (Mathf.Abs (Input.GetAxisRaw (tempAxis)) >= watchFocusPrev) {
			focusing = true;
			//watchFocusPrev = Mathf.Abs (Input.GetAxisRaw (tempAxis));
			//}
		}

		if (focusing)
		{
			// increase timer while control held down
			watchTimer += Time.unscaledDeltaTime;
			filler.localScale = new Vector3(Mathf.Clamp01(watchTimer / assignNeededDuration), 1, 1);
			
			// check if timer maxed
			if (watchTimer >= assignNeededDuration)
			{
				if (watchFocusType >= 0)
				{
					// this is a gamepad axis control, begin limits adjust
					stickLimitsTempGamepad = watchFocusType;
					stickLimitsTempAxis = watchFocusValue;
					BeginStickLimits(assignWaiting);
				}
				else
				{
					// store control type/value
					ctrlType[assignWaiting] = watchFocusType;
					ctrlVal[assignWaiting] = watchFocusValue;
				}
				if (Globals.me) Globals.me.MenuSound(0);
				CancelAssign();
			}
		}
		else if (watchFocusType != -3)
		{
			// we were watching a control but player released it
			filler.gameObject.SetActive(false);
			watchTimer = 0;
			watchFocusType = -3;
			watchFocusValue = -1;
			//watchFocusPrev = 0;
		}

		// store previous watching state
		bool watching = watchFocusType != -3;

		if (watchFocusType == -3)
		{
			// check if button pressed
			for (int i = 0; i < KeyValues.Length; i++)
			{
				if (Input.GetKeyDown((KeyCode)KeyValues[i]))
				{
					watchFocusType = -2;
					watchFocusValue = KeyValues[i];
					break;
				}
			}
		}
		if (watchFocusType == -3 || watchFocusType >= 0)
		{
			// check if gamepad axis moved
			string axis;
			for (int i = 1; i <= maxGamepads; i++)
			{
				for (int j = 1; j <= maxAxes; j++)
				{
					axis = "J" + i + "A" + j;

					// check if this axis can override any currently moved axis
					bool canOverride = true;
					if (watchFocusType >= 0 &&
						(Mathf.Abs(Input.GetAxisRaw(axis)) <= Mathf.Abs(Input.GetAxisRaw(tempAxis)) + .5f
						|| axis.Equals(tempAxis))) canOverride = false;
					
					// check if axis moved just now
					bool moved = Mathf.Abs(Input.GetAxisRaw(axis) - watchAxes[i - 1][j - 1]) > .6f;
					if (moved) watchAxes[i - 1][j - 1] = Input.GetAxisRaw(axis);
					
					if (canOverride && moved)
					{
						watchFocusType = i - 1;
						watchFocusValue = j - 1;
						tempAxis = axis;
						//watchFocusPrev = watchAxes[i - 1][j - 1];
						watchTimer = 0;
						//break;
					}
					//watchAxes[i - 1][j - 1] = Input.GetAxisRaw (axis);
				}
			}
		}
		if (watchFocusType == -3)
		{
			// check for mousewheel
			var wheel = Input.GetAxisRaw("Mousewheel");
			if (Mathf.Abs(wheel) > .5f)
			{
				// instantly store control (can't hold down)
				ctrlType[assignWaiting] = -1;
				ctrlVal[assignWaiting] = wheel < 0 ? 0 : 1;
				CancelAssign();
			}
		}
		
		// if newly watched control, show fillbar
		if (!watching && watchFocusType != -3)
		{
			filler = assignButtons[assignWaiting].transform.Find("filler");
			filler.gameObject.SetActive(true);
			filler.localScale = new Vector3(0, 1, 1);
		}
	}

	/// <summary>
	/// get indicative name for this control
	/// </summary>
	/// <param name="control">control (see Control enum)</param>
	/// <returns>control name</returns>
	public static string GetControlName(Control control)
	{

		return ControlNames[(int)control].Replace('_', ' ');
	}

	/// <summary>
	/// get display text for this control
	/// </summary>
	/// <param name="control">control (see Control enum)</param>
	/// <returns>control assignment name, or (unassigned) if invalid/unset</returns>
	public static string GetControlValueName(Control control)
	{

		if (ctrlVal[(int)control] < 0) return "(unassigned)";

		// KeyCode
		if (ctrlType[(int)control] == -2)
		{
			var i = Array.FindIndex(KeyValues, v => v == ctrlVal[(int)control]);
			if (i < 0) return "(unassigned)";
			return KeyNames[i];
		}

		// Mousewheel
		if (ctrlType[(int)control] == -1)
		{
			if (ctrlVal[(int)control] == 0) return "Mousewheel Down";
			return "Mousewheel Up";
		}

		// gamepad axis
		if (ctrlType[(int)control] >= 0 && ctrlType[(int)control] < maxGamepads)
		{
			return "Joy " + (ctrlType[(int)control] + 1) + " Axis " + (ctrlVal[(int)control] + 1);
		}

		// default
		return "(undefined)";
	}

	/// <summary>
	/// get this control's current press state
	/// </summary>
	/// <param name="control">control (see Control enum)</param>
	/// <returns>control's current press state (0 to 1, 1 meaning fully pressed)</returns>
	public static float GetControl(Control control)
	{

		int c = (int)control;
		if (ctrlVal[c] < 0) return 0;

		// KeyCode
		if (ctrlType[c] == -2)
		{
			return Input.GetKey((KeyCode)ctrlVal[c]) ? 1f : 0f;
		}

		// Mousewheel
		if (ctrlType[c] == -1)
		{
			var wheel = Input.GetAxisRaw("Mousewheel");
			if (ctrlVal[c] == 0 && wheel < -.5f) return 1f;
			if (ctrlVal[c] == 1 && wheel > .5f) return 1f;
			return 0f;
		}

		// gamepad axis
		string axis;
		if (ctrlType[c] >= 0 && ctrlType[c] < maxGamepads)
		{
			axis = "J" + (ctrlType[c] + 1) + "A" + (ctrlVal[c] + 1);
			float val = (Input.GetAxisRaw(axis) - ctrlLimitMin[c]) / (ctrlLimitMax[c] - ctrlLimitMin[c]);
			//OutputDebug.me.text.text = val.ToString ();
			return val;
		}

		// default
		return 0f;
	}

	/// <summary>
	/// begins assign for this control-assigner button
	/// </summary>
	/// <param name="index">index from assignButtons array (corresponds to Control enum)</param>
	public void BeginAssign(int index)
	{
		// end any pending assigns
		if (gettingStickLimits > 0) CancelStickLimits();
		if (assignWaiting != -1) CancelAssign();

		// activate this assign
		assignWaiting = index;
		assignButtons[index].GetComponentInChildren<Text>().text = assignText;
		//assignButtons[index].GetComponent<Image> ().color = assignColorHighlight;
		assignButtons[assignWaiting].interactable = false;
		UpdateWatchedAxes();
	}

	/// <summary>
	/// update values of all axes on all gamepads
	/// </summary>
	private void UpdateWatchedAxes()
	{

		string axis;
		for (int i = 1; i <= maxGamepads; i++)
		{
			for (int j = 1; j <= maxAxes; j++)
			{
				axis = "J" + i + "A" + j;
				watchAxes[i - 1][j - 1] = Input.GetAxisRaw(axis);
			}
		}
	}

	/// <summary>
	/// exit current assign process without saving values
	/// </summary>
	public void CancelAssign()
	{

		if (assignWaiting < 0) return;

		// reset button text
		assignButtons[assignWaiting].GetComponentInChildren<Text>().text =
			GetControlValueName((Control)assignWaiting);
		//assignButtons[assignWaiting].GetComponent<Image> ().color = assignColorDefault;
		assignButtons[assignWaiting].interactable = true;
		
		// reset watcher variables and fillbar
		watchTimer = 0;
		watchFocusType = -3;
		watchFocusValue = -1;
		//watchFocusPrev = 0;
		var filler = assignButtons[assignWaiting].transform.Find("filler");
		filler.gameObject.SetActive(false);
		assignWaiting = -1;
	}

	/// <summary>
	/// read controls from config file
	/// </summary>
	/// <returns>whether successful</returns>
	public static bool ReadConfig()
	{

		Init();
		if (!initialized || !File.Exists(configFile)) return false;
		bool complete = false;
		try
		{
			using (XmlReader reader = XmlReader.Create(configFile))
			{
				// loop through all control tags
				while (reader.ReadToFollowing("control"))
				{
					// get control name
					string optName = reader.GetAttribute("name");
					int ctrl = Array.FindIndex(ControlNames, n => n.Equals(optName));
					if (ctrl < 0) continue;

					// get type and value
					string optType = reader.GetAttribute("assignedType");
					string optVal = reader.GetAttribute("assignedValue");
					int tempType = ctrlType[ctrl];
					int tempVal = ctrlVal[ctrl];
					int.TryParse(optType, out tempType);
					int.TryParse(optVal, out tempVal);
					bool valid = false;
					float axisMin = 0f, axisMax = 0f;

					if (tempVal == -1)
					{
						// unassigned
						valid = true;
					}
					else if (tempType == -2)
					{
						// keycode
						if (Array.Exists(KeyValues, n => n == tempVal)) valid = true;
					}
					else if (tempType == -1)
					{
						// mousewheel
						if (tempVal == 0 || tempVal == 1) valid = true;
					}
					else if ((tempType >= 0 && tempType < maxGamepads))
					{
						// gamepad axis
						if (tempVal >= 0 && tempVal < maxAxes) valid = true;

						// read min limit
						string limitStr = reader.GetAttribute("min");
						if (int.TryParse(limitStr, out var limit))
						{
							axisMin = limit / 100f;

							// read max limit
							limitStr = reader.GetAttribute("max");
							if (int.TryParse(limitStr, out limit)) axisMax = limit / 100f;
							else valid = false;
						}
						else valid = false;
					}
					if (valid)
					{
						// save if valid
						ctrlType[ctrl] = tempType;
						ctrlVal[ctrl] = tempVal;
						if (tempType >= 0)
						{
							ctrlLimitMin[ctrl] = axisMin;
							ctrlLimitMax[ctrl] = axisMax;
						}
					}
				}
				complete = true;
			}
		}
		catch (System.Security.SecurityException e)
		{
			Debug.Log(e);
		}
		catch (XmlException e)
		{
			Debug.Log(e);
		}
		catch (System.InvalidOperationException e)
		{
			Debug.Log(e);
		}
		return complete;
	}

	/// <summary>
	/// save controls to config file
	/// </summary>
	/// <returns>whether successful</returns>
	public static bool WriteConfig()
	{

		Init();
		if (!initialized) return false;
		XmlWriterSettings xmlWriterSettings = new XmlWriterSettings()
		{
			Indent = true,
			IndentChars = "\t",
			NewLineOnAttributes = true
		};

		bool complete = false;
		try
		{
			using (XmlWriter w = XmlWriter.Create(configFile, xmlWriterSettings))
			{
				w.WriteStartElement("controlGroup");
				for (int i = 0; i < ctrlVal.Length; i++)
				{
					// start control tag
					w.WriteStartElement("control");
					// write name, type and value of this control
					w.WriteAttributeString("name", ControlNames[i]);
					w.WriteAttributeString("assignedType", ctrlType[i].ToString());
					w.WriteAttributeString("assignedValue", ctrlVal[i].ToString());
					if (ctrlType[i] >= 0)
					{
						// min/max for gamepad axis
						w.WriteAttributeString("min",
							Mathf.RoundToInt(ctrlLimitMin[i] * 100).ToString());
						w.WriteAttributeString("max",
							Mathf.RoundToInt(ctrlLimitMax[i] * 100).ToString());
					}
					w.WriteEndElement();
					// end control tag
				}
				w.WriteEndElement();
				w.Flush();
				complete = true;
			}
		}
		catch (InvalidOperationException e)
		{
			Debug.Log(e);
		}
		return complete;
	}
}
